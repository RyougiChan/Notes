# 前端知识点总结

## 目录

## 知识点

### HTTP

#### HTTP 请求方法

1. HTTP1.1 中仅**GET**和**HEAD**两个方法
2. **GET**是最常用的方法，通常用于**请求服务器发送某个资源**
3. **HEAD**与**GET**类似，但**服务器在响应中值返回首部，不返回实体的主体部分**
4. **PUT**让服务器**用请求的主体部分来创建一个由所请求的URL命名的新文档，或者，如果那个URL已经存在的话，就用这个主体替代它**
5. **POST**起初是用来向服务器输入数据。
6. **TRACE**会在目的服务器端发起一个**环回诊断**，最后一站的服务器会弹回一个TRACE响应并在响应主体中携带它收到的原始请求报文。TRACE方法主要用于诊断，用于验证请求是否如愿穿过了请求/响应链。
7. **OPTIONS**方法请求web服务器告知其支持的各种功能。可以查询服务器支持哪些方法或者对某些特殊资源支持哪些方法。
8. **DELETE**请求服务器删除请求URL指定的资源

#### 从浏览器地址栏输入URL到显示页面经历的过程

1. 输入URL地址回车
2. 检查浏览器缓存:
    1. 命中缓存
        1. 检查缓存是否过期(`Expires`和`Cache-Control`)，若未过期，直接返回结果给浏览器
        2. 检查缓存是否过期，若已过期，向服务器发起请求验证验证资源是否未修改(`ETag`和`if-last-modify`)
    2. 未命中缓存，继续
3. 进行域名解析
    1. 检查浏览器 DNS 缓存
        1. 若命中且新鲜(TTL)，则返回上一次解析的 IP，解析结束
        2. 若未命中，继续下一步
    2. 检查本地 HOST 文件是否有相应域名配置
        1. 若命中，则返回 HOST 的配置 IP，解析结束
        2. 未命中，继续下一步
    3. 检查路由 DNS 缓存
        1. 若命中，则返回缓存的 IP，解析结束
        2. 未命中，继续
    4. 向本地 ISP(LDNS) 发起查询
        1. 若 ISP 命中缓存，则返回缓存的 IP，解析结束
        2. 若 ISP 未命中缓存，则继续
    5. LDNS 向根域名`.`服务器查询，然后向其中一台发起请求，根域名服务器返回给 LDNS 一个所查询域的主域名服务器(gTLD)
    6. LDNS 向gTLD发起查询，接受请求的gTLD查找并返回这个域名对应的Name Server(NS)的地址，这个Name Server一般是网站注册的域名服务器。Name Server 根据映射关系表找到目标 IP，返回给LDNS
    7. LDNS接受返回的IP和TTL值，并缓存这个域名和IP的对应关系，缓存时间由TTL控制
    8. LDNS把解析的结果返回给用户，用户根据TLL值缓存在本地系统缓存中，域名解析结束
4. 若解析得到 IP，进行下一步，否则浏览器响应 DNS 解析错误结果
5. 建立 TCP 连接(三次握手)
    1. 浏览器端发送建立连接握手包(SYN包，`SYN=1,Seq=X`)，进入 `SYN_SENT` 状态
    2. 服务器端收到握手包后给浏览器端发送握手包(SYN-ACK包，`SYN=1,ACK=X+1,Seq=Y`)，进入 `SYN_RECV` 状态
    3. 浏览器端收到握手包后再次给服务端发送握手包(SYN包，`SYN=2,ACK=Y+1`)
    4. 服务器端收到握手包后双方进入 `ESTABLISHED` 状态
6. 浏览器发起 HTTP 请求
7. 服务器判断请求并做出 HTTP 响应
    1. 若请求头含有 `If-None-Match`/`If-Modified-Since` 头，则判断资源的新鲜度，若新鲜则给浏览器发送 `304` 响应告知浏览器缓存有效
    2. 若不包含，服务器获取相应资源并做出响应响应
    3. 浏览器收到 304 响应后更新缓存有效时间等信息，收到 2xx 响应则展示结果，若可缓存则进行结果缓存
    4. 若响应为 HTML 文档，则执行以下步骤
        1. 自文档上至下构建 DOM 树，遇到 `img`, `link`, `script` 资源文件时进行下载
        2. 构建 CSSDOM 树
        3. 根据 DOM 树和 CSSDOM 渲染页面
        4. 解析 JavaScript
        5. 显示页面
8. 一段时间后关闭 TCP 连接(四次挥手)，以浏览器主动断开为例
    1. 浏览器发起关闭 HTTP 请求握手包(FIN包，`FIN=1,ACK=Z,Seq=X`)，进入 `FIN_WAIT_1` 状态
    2. 服务器收到握手包后给浏览器发送通知握手包(ACK包，`ACK=X+1,Seq=Y`)，服务器进入 `CLOSE_WAIT` 状态，浏览器端进入 `FIN_WAIT_2` 状态
    3. 服务器发送关闭握手包(FIN包，`FIN=1,ACK=X+1,Seq=Y`)，浏览器段进入 `LAST_ACK` 状态
    4. 浏览器收到握手包后，最后发送一次握手包(ACK包，`ACK=Y+1,Seq=X+1`)，状态变成 `TIME_WAIT`
    5. 服务器端接收到通知握手包后关闭 TCP 连接，浏览器端一段时间后也关闭 TCP 连接
