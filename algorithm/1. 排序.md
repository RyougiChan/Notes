# 排序(正序排序)

## 冒泡排序

- 思想

相邻元素两两比较大小(优先度)，大的排后

- 操作

```js
let bubbleSort = (arr) => {
    let temp;
    for(let i = 0; i < arr.length; i++) {
        for(let j = i; j < arr.length; j++) {
            if(arr[i] > arr[j]) {
                temp = arr[i];
                arr[i] = arr[j];
                arr[j] = temp;
            }
        }
    }
    return arr;
}
```

## 插入排序

- 思想

把待排序的记录按其关键码值的大小逐个插入到一个已经排好序的有序序列中，直到所有的记录插入完为止，得到一个新的有序序列。

### 直接插入排序

- 操作

```js
let straightInsertionSort = (arr) => {
    for(let i = 1; i < arr.length; i++) {
        let s = 0;
        while(s < i) {
            if(arr[i] < arr[s]) {
                let temp = arr[i];
                arr[i] = arr[s];
                arr[s] = temp;
            }
            s++;
        }
    }
}
```

### 折半插入排序（二分插入排序）

将直接插入排序中寻找A[i]的插入位置的方法改为采用折半比较，即可得到折半插入排序算法。

- 操作

```js
let binarySearch = (arr, start, end, tar) => {
    for(let k = start; k < end; k++) {
        if(arr[k] < tar && arr[k+1] >= tar) {
            return k;
        }
    }
}

let binaryInsertionSort = (arr) => {
    for(let i = 1; i < arr.length; i++) {
        let index = binarySearch(arr, 0, i, arr[i]);
        let temp = arr[i];
        for(let j = i; j > index; j--) {
            arr[j] = arr[j-1];
        }
        arr[index] = temp;
    }
    return arr;
}
```

## 快速排序

- 思想

先忽略排序，取一个数 `a`，然后把小于 `a` 的数放在 `a` 左侧，大于 `a` 的放在其右侧，分成两个两组数，再对这两组数做相同的操作，直到无法再分出两组数。

![QuickSort](https://upload.wikimedia.org/wikipedia/commons/thumb/6/6a/Sorting_quicksort_anim.gif/220px-Sorting_quicksort_anim.gif)(from wikipedia)

- 操作

```js
let quickSort = (arr, low, high) => {
    let tar = arr[low], i = low, j = high;
    if(i < j) {
        while(i != j) {
            while(i < j && arr[j] >= tar) {
                j--;
            }
            if(i < j) arr[i] = arr[j];
            while(i < j && arr[i] <= tar) {
                i++;
            }
            if(i < j) arr[j] = arr[i];
        }
        arr[i] = tar;
        quickSort(arr, low, i - 1);
        quickSort(arr, i + 1, high);
    } else {
        return arr;
    }
}
```