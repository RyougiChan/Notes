# 排序(正序排序)

## 冒泡排序

- 思想

相邻元素两两比较大小(优先度)，大的排后

- 操作

```js
let bubbleSort = (arr) => {
    let temp;
    for(let i = 0; i < arr.length; i++) {
        for(let j = i; j < arr.length; j++) {
            if(arr[i] > arr[j]) {
                temp = arr[i];
                arr[i] = arr[j];
                arr[j] = temp;
            }
        }
    }
    return arr;
}
```

## 直接插入排序

- 思想

把待排序的记录按其关键码值的大小逐个插入到一个已经排好序的有序序列中，直到所有的记录插入完为止，得到一个新的有序序列。

- 操作

```js
let straightInsertionSort = (arr) => {
    for(let i = 1; i < arr.length; i++) {
        let s = 0;
        while(s < i) {
            if(arr[i] < arr[s]) {
                let temp = arr[i];
                arr[i] = arr[s];
                arr[s] = temp;
            }
            s++;
        }
    }
}
```

## 快速排序

- 思想

先忽略排序，取一个数 `a`，然后把小于 `a` 的数放在 `a` 左侧，大于 `a` 的放在其右侧，分成两个两组数，再对这两组数做相同的操作，直到无法再分出两组数。

![QuickSort](https://upload.wikimedia.org/wikipedia/commons/thumb/6/6a/Sorting_quicksort_anim.gif/220px-Sorting_quicksort_anim.gif)(from wikipedia)

- 操作

```js
let quickSort = (arr, low, high) => {
    let tar = arr[low], i = low, j = high;
    if(i < j) {
        while(i != j) {
            while(i < j && arr[j] >= tar) {
                j--;
            }
            if(i < j) arr[i] = arr[j];
            while(i < j && arr[i] <= tar) {
                i++;
            }
            if(i < j) arr[j] = arr[i];
        }
        arr[i] = tar;
        quickSort(arr, low, i - 1);
        quickSort(arr, i + 1, high);
    } else {
        return arr;
    }
}
```